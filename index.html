
<!DOCTYPE html>
<html>

<html>
<head>

    <script src="js/ImprovedNoise.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/MinimalComps-0.1.min.js"></script>
    <script src="js/TweenLite.min.js"></script>
    <script src="js/jquery-1.6.4.min.js"></script>



  <!---  PHYSICS LIBRARIES   --->

<!--     <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="http://cdn.iamwebdeveloper.in/js/stats.js/r11/Stats.js"></script> -->
    <!-- Core -->
    <script src="js/compiled/base.js"></script>
  <script src="js/sketch.min.js"></script>
    <script src="js/compiled/math/Random.js"></script>
    <script src="js/compiled/math/Vector.js"></script>
    <!-- Integratjs/ors -->
    <script src="js/compiled/engine/integrator/Integrator.js"></script>
    <script src="js/compiled/engine/integrator/Euler.js"></script>
    <script src="js/compiled/engine/integrator/ImprovedEuler.js"></script>
    <script src="js/compiled/engine/integrator/Verlet.js"></script>
    <!-- Engine -js/-->
    <script src="js/compiled/engine/Particle.js"></script>
    <script src="js/compiled/engine/Physics.js"></script>
    <script src="js/compiled/engine/Spring.js"></script>
    <!-- Behavioujs/rs -->
    <script src="js/compiled/behaviour/Behaviour.js"></script>
    <script src="js/compiled/behaviour/Attraction.js"></script>
    <script src="js/compiled/behaviour/Collision.js"></script>
    <script src="js/compiled/behaviour/ConstantForce.js"></script>
    <script src="js/compiled/behaviour/EdgeBounce.js"></script>
    <script src="js/compiled/behaviour/EdgeWrap.js"></script>
    <script src="js/compiled/behaviour/Wander.js"></script>

  <script src="js/renderers/SVGRenderer.js"></script>


  <!-----  MAY NOT NEED THEM ALL !   ------>

    <link type="text/css" rel="stylesheet" href="styles/normalize.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css" />
    <link type="text/css" rel="stylesheet" href="styles/main.css" />


    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
    <meta http-equiv="cleartype" content="on">
    <meta name="Â§xapple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="viewport" content = "width = device-width, initial-scale = 1, minimum-scale = 1, maximum-scale = 1, user-scalable = no" />
    <title></title>
</head>


<body class="page1">
  <header><img src="images/nissan_logo.png" id="logo"></header>

      <div class="button-wrapper">
         <input type="button" id="fs"  value="Make the switch">
      </div>


        <video id="video" style="display:none" width="100%" height="100%" controls="false" preload="false" >
        <source src="videos/video.mp4" type='video/mp4' />
        </video>
  
  <canvas id="surface" width="100%" height="100%" style='z-index : -1; position: absolute;'></canvas>
  <div id="container" style='z-index : 1; position: absolute;'></div>

          <div id="page1" class="show">


            <div class="text">
            <h1>The 100% Electric New Leaf<br /><span>You'll know it when you feel it</span></h1>
              <p class="list">Zero emissions* | Connected | Instant torque</p>
                <p class="small">While driving</p>

            </div>
          </div>
        <div  id="page2" class="hide">

          <div class="text">
          <h1> Feel <span> Connected</span></h1>
          <p class="list">Remote access | Voice controls | Charging network</p>

          <p class="desc">Be in sync with your car. You can check and control the Nissan LEAF's charge and adjust the air con remotely via the Carwings app. Tell LEAF to guide you home  with voice-controlled navigation. And change on the go through a network of the rapid charge points - located for you by LEAF.
          </p>
        </div>
        </div>
        <div id="page3" class="hide">

          <div class="text">
          <h1> Feel <span> the torque</span></h1>
          <p class="list">Responsive | Dynamic | Quietly impressive</p>

          <p class="desc">Everyone who experiences the unique feeling of accelerating in the 100% electric Nissan LEAF  wants  to talk about it. To share the sensation of instant torque, smoothly delivered from the moment the foot touches the pedal.</p>

          <p class="desc">With LEAF, you get incredible performance with zero noise and zero emissions when you drive.</p>
        </div>

        </div>





    <script>


      var container, stats;

			var camera, scene, renderer;

			var mesh, plane;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

      var targetRotation = 0;
      var targetRotationOnMouseDown = 0;

      var mouseX = 0;
      var mouseXOnMouseDown = 0;


      ////CAR VARS




      var carX = 0;
      var currX = 0;
      var carWidthPerc = .3;
      var carHeightPerc = .2;
      var carInitY = .68;
      var carInitX = -.05;
      var offRightPerc = 1.3;
      var rightMarginPerc = .9;


      var canvas ;//= document.getElementById('surface');
      var context;// = canvas.getContext('2d');


      var canvHeigh = window.innerHeight;
      var carY = canvHeigh*carInitY;
      var canvWid = window.innerWidth;
      var carW = canvWid*carWidthPerc;
      var carH = canvHeigh*carHeightPerc;

      var currentPage = 0;
      var totalPages = 3;
      var animatingToNextPage = false;

      var animTarg = false;
      var carVisible = true;

      var lastX = 0; //the last recorded x position of the car (carX is the current)
      var movementX; //the amount to move

      var CAR_ANIM_OFF_DURATION = 1;
      var CAR_ANIM_IN_DURATION = 1;

      ////PHYSICS

      var physics, avoidMouse, pullToCenter, collision, example, cell;
      //TODO- use a quality variable that sets the number of squares so the number of rows and columns are calculated for the orientation
      var COLUMNS = 12;
      var ROWS = 12;
      var PARTICLE_RADIUS = 5;

      initTouch();
      initPhysics();
      initTouchListeners();

      addStats();

      init3D();
      animate();
      //   addControls();


      function addStats(){
        container = document.getElementById( 'container' );
        stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

      }

       function initTouch(){

        canvas = document.getElementById('surface');
        context = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

         // document.addEventListener( 'touchstart', onDocumentTouchStart, false );
         //   document.addEventListener( 'touchmove', onDocumentTouchMove, false );

       }

       function initTouchListeners(){
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );
        document.addEventListener( 'touchend', onDocumentTouchUp, false );
       }

      function updateCarSize(){
        canvHeigh = window.innerHeight;
        carY = canvHeigh*carInitY;
        canvWid = window.innerWidth;
        carW = canvWid*carWidthPerc;
        carH = canvHeigh*carHeightPerc;

      }


      function initPhysics(){

        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        physics = new Physics();
        physics.integrator = new Verlet();
        avoidMouse = new Attraction();
        pullToCenter = new Attraction();
        collision = new Collision();
        setupExample();
      }

      function setupExample(){

        ///SETUP

        example = Sketch.create({container:document.body});
        example.setup = function() {


          var spaceX = Math.floor(window.innerWidth/COLUMNS);
          var spaceY = Math.floor(window.innerHeight/ROWS);
          var s, stiffness, size;
          size = 60;
          stiffness = 1;
          cell = [];
          for ( var i = 0; i < COLUMNS+1; i++ ) {
            //create a new array at each index
            cell[i] = [];
            for( var j = 0; j<ROWS+1; j++){

              var particle = new Particle( 10 );
              //fix the top ones
              if (j==0 || j == ROWS){
                particle.fixed = true;//j === 0;
              }
              var position = new Vector( spaceX*i, spaceY*j );
              particle.moveTo( position );
              particle.setRadius( PARTICLE_RADIUS );

              if (i>0){
                s = new Spring(particle, cell[i-1][j], spaceX, stiffness );
                physics.springs.push(s);
              }


              if (j > 0) {
                s = new Spring(particle, cell[i][j - 1], spaceY, stiffness);
                physics.springs.push(s);
              }



              // Make it collidable
              //  collision.pool.push( particle );

              // Apply behaviours
              //  particle.behaviours.push( avoidMouse, pullToCenter, collision );

              // Add to the simulation
              physics.particles.push( particle );
              cell[i][j] = particle;

            }

          }

          /*    pullToCenter.target.x = this.width / 2;
          pullToCenter.target.y = this.height / 2;
          pullToCenter.strength = 500;
          avoidMouse.setRadius( 200 );
          avoidMouse.strength = -3000;*/

          example.fillStyle = '#ff00ff';
          // }
        ////DRAW



        }



      }

			function init3D() {


				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = -1320;

				scene = new THREE.Scene();
        var material = new THREE.MeshBasicMaterial({ color: 0xffffff, doubleSided: true});


        var lavaTexture = THREE.ImageUtils.loadTexture( 'images/grad.jpg' );
      	var lavaMaterial = new THREE.MeshBasicMaterial( { map: lavaTexture } );


        material.doubleSided = true;
        material.side = THREE.DoubleSide;
				var quality = 8, step = 1024 / quality;
				plane = new THREE.PlaneGeometry( 768, 1024, COLUMNS , ROWS  );
        //  plane.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
        console.log(plane);
				for ( var i = 0, l = plane.vertices.length; i < l; i ++ ) {

					var x = i % COLUMNS, y = ~~ ( i / COLUMNS );
          plane.vertices[ i ].y = y* (window.innerHeight/ROWS);
          plane.vertices[ i ].x = x* (window.innerWidth/COLUMNS);
          plane.vertices[ i ].z = 0;


				}
				plane.computeVertexNormals();
        plane.doubleSided = true;
        plane.computeFaceNormals();
        //        plane.computeCentroids();
        plane.__dirtyNormals = true;


				mesh = new THREE.Mesh( plane, material );
        mesh.doubleSided = true;
				scene.add( mesh );

        //				renderer = new THREE.CanvasRenderer();
        renderer = new THREE.SVGRenderer();
          renderer.setSize( window.innerWidth, window.innerHeight );//TODO - reset size of renderer on rotate?
				container.appendChild( renderer.domElement );
        container.setAttribute('style', 'z-index: -10; position:absolute');


        mesh.rotation.y = Math.PI;//  *.5;
			}

      var cameraXSlider;
      var meshYRotSlider;
      var meshXRotSlider;
      var meshZRotSlider;

      var containerControls;

      function addControls(){
        containerControls = document.getElementById( 'containerControls' );
        cameraZSlider = new mc.HSlider(containerControls, 10, 80, onCamZSliderChange)
        .bindLabel(new mc.Label(containerControls, 15, 100).setAlign("center"), 0);
        cameraZSlider.setMinimum( -6000 );
    		cameraZSlider.setMaximum( 6000 );

        meshYRotSlider = new mc.HSlider(containerControls, 10, 100, onMeshRotYChange)
        .bindLabel(new mc.Label(containerControls, 15, 140).setAlign("center"), 0);
        meshYRotSlider.setMinimum( -Math.PI*2 );
    		meshYRotSlider.setMaximum(Math.PI*2);

        meshXRotSlider = new mc.HSlider(containerControls, 10, 140, onMeshRotXChange)
        .bindLabel(new mc.Label(containerControls, 15, 140).setAlign("center"), 0);
        meshXRotSlider.setMinimum( -Math.PI*2 );
    		meshXRotSlider.setMaximum(Math.PI*2);

        meshZRotSlider = new mc.HSlider(containerControls, 10, 180, onMeshRotZChange)
        .bindLabel(new mc.Label(containerControls, 15, 140).setAlign("center"), 0);
        meshZRotSlider.setMinimum( -Math.PI*2 );
    		meshZRotSlider.setMaximum(Math.PI*2);


      }

      function onCamZSliderChange( e ){

        camera.position.z = cameraZSlider.getValue();
        console.log("Camera z change:"+camera.position.z);
    	}

      function onMeshRotYChange( e ){

        mesh.rotation.y = meshYRotSlider.getValue();
        console.log("mesh rot Y:"+ mesh.rotation.y);
    	}

       function onMeshRotXChange( e ){

        mesh.rotation.x = meshXRotSlider.getValue();
        console.log("mesh rot x:"+ mesh.rotation.x);
    	}

       function onMeshRotZChange( e ){

        mesh.rotation.z = meshZRotSlider.getValue();
        console.log("mesh rot z:"+ mesh.rotation.z);
    	}





      ///////   MOUSE LISTENERS   //////////////

      function onDocumentMouseDown(){
        console.log("m down");
        event.preventDefault();
        mouseXOnMouseDown = event.clientX - windowHalfX;
        targetRotationOnMouseDown = targetRotation;

      }


      function onDocumentMouseMove( e ) {
          console.log("mmove");
          mouseX = event.clientX - windowHalfX;
          targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
          console.log(targetRotation);
      }

      function onDocumentMouseUp( event ) {

          document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
          document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
          document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

      }


     function onDocumentMouseOut( event ) {

          document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
          document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
          document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

      }

    var tDown = false;

      //////////  TOUCH LISTENERS //////////////////


      function onDocumentTouchStart(event){
        var x = event.targetTouches[0].pageX;
        var y = event.targetTouches[0].pageY;

        avoidMouse.target.x = x;
        avoidMouse.target.y = y;
        tDown = true;
        event.preventDefault();
      }

      function onDocumentTouchUp(event){
        console.log("t up");
        tDown = false;
        event.preventDefault();
      }


      var currX = 0;

      function onDocumentTouchMove(event){

        var x = event.targetTouches[0].pageX,
        y = event.targetTouches[0].pageY;


        if (!animTarg){
          currX = x;
        }


        drawCircle(x,y, 40, '#ffff00');
        //        camera.position.x = -300;//((y/window.innerHeight)*6000);

        //     mesh.rotation.z =((x/window.innerWidth)*Math.PI*2);

        avoidMouse.target.x = x;
        avoidMouse.target.y = y;
        event.preventDefault();

      }

      //////////////////////////////////////

      function drawCircle(x, y, radius, color){
        canvas.width  =canvas.width;
        context.beginPath();
        context.fillStyle = color;
        context.arc(x,y,radius,0,Math.PI*2);
        context.fill();
      }


			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			function onDocumentMouseMove(event) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

      //THIS FUNCTION WILL BE CALLED WHEN THE CAR HAS REACHED THE RIGHT MARGIN

      function showNextPage(){
        //increment or reset the page number
        if (currentPage<totalPages-1){
          currentPage++;
          console.log("display  " + currentPage);
        }else{
          currentPage = 0;
        }


        showDivs(currentPage);//add code to show correct content here:



      }




     function showDivs() {
       var ids = ["page1", "page2", "page3"];
       // console.log(ids);
        for(var i = 0; i < ids.length; i++) {


          if(i == currentPage){
            var lastPage = currentPage-1;
            if (lastPage<0){
              lastPage = totalPages-1;
            }
            var currDiv = document.getElementById(ids[lastPage]);
            currDiv.classList.remove('show');
            document.body.classList.remove(ids[lastPage]);
            document.body.classList.add(ids[currentPage]);
            currDiv.classList.add('hide');
            var thisD = document.getElementById(ids[currentPage]);
            console.log("div?:"+thisD);
            thisD.classList.remove('hide');
            thisD.classList.add('show');

          }

        }

      }


      function drawMargin(){

        context.beginPath();
        context.fillStyle = "rgba(104, 255, 109, 0.5)";
        context.fillRect(window.innerWidth*rightMarginPerc, 0, window.innerWidth*(1-rightMarginPerc), window.innerHeight);
        context.fill();



      }


      function drawCircle(x, y, radius, color){
        canvas.width  =canvas.width;
        context.beginPath();
        context.fillStyle = color;
        context.arc(x,y,radius,0,Math.PI*2);
        context.fill();
      }


      function drawCar(x, y, width, height, color){
        //  console.log("draw"+x+":"+ y);

        context.fillStyle = color;
        context.beginPath();
        context.fillRect(x,y,width,height);
        context.fill();
      }

      function resetCarPos(){
        console.log("reset");
        animatingToNextPage = true;
        animateCarOffRight();


        showNextPage(); // TODO move to when car is off the pagew


      }


      function animateCarOffRight(){
        var targOff = window.innerWidth*offRightPerc;
        console.log("anim offright:"+targOff);
        TweenLite.to(this, CAR_ANIM_OFF_DURATION, {carX:targOff, onComplete:carAtRight});
      }

      function carAtRight(){
        console.log("carAtRight");
        carX = 0-(window.innerWidth*carWidthPerc);
        animateCarIn();

      }

      function animateCarIn(){
        TweenLite.to(this, CAR_ANIM_IN_DURATION, {carX:window.innerWidth*carInitX, onComplete:carIsHere});

      }

      function carIsHere(){
        console.log("car is here");
        currX = carX;

        animatingToNextPage = false;

      }

      function drawPhysics(){

        //          physics.step();
          var fillStyle = '#00ff00';
          //render particles
          for( var i=0, n = physics.particles.length; i<n; i++){

            var particle = physics.particles[i];
            example.beginPath();
            if (particle.underCar){
             example.fillStyle = fillStyle;
            }else{
              example.fillStyle = 'ff00ff';
            }
            example.arc( particle.pos.x, particle.pos.y, particle.radius, 0, Math.PI * 2 );
            example.fill();
            example.closePath();

          }
          var spring;
          //render springs
          for (i=0; i<physics.springs.length; i++){
            example.strokeStyle = '#ffff00';
            spring = physics.springs[i];
            example.beginPath();
            example.moveTo(spring.p1.pos.x, spring.p1.pos.y);
            example.lineTo(spring.p2.pos.x, spring.p2.pos.y);
            example.closePath();
            example.stroke();
          }

      }





      function checkPointsInsideCar(){
        var part,i;
        for( i= 0; i<physics.particles.length; i++){
          part = physics.particles[i];
          if (point_in_rectangle(part.pos.x, part.pos.y, carX, carY-(carH*.5), carX+carW, carY+(carH*.5))){
            part.underCar = true;
            part.pos.x += .5*movementX;
          }else{
            part.underCar = false;
          }
        }
      }


      function updateVertices(){
        // console.log("u");
        var i, particle, vertex, pos, theX, theY,
            ratioX = 1.8,
            ratioY = 1.8;

        for(i = 0; i<physics.particles.length; i++){
          vertex = mesh.geometry.vertices[i];
          particle = physics.particles[i];
          pos = particle.pos;
          //TODO figure out how to make the offsets dynamic
          theX = pos.x;//-650;
          theY = pos.y-768;

          theX *= ratioX;
          theY *= ratioY;


          //   theX = pos.x;
          // theY = pos.y;
          vertex.x = theX-700;
          vertex.y = theY+500;

          //          part = physics.particles[i];
          //console.log(physics.particles[i]);
        //  vertex.x = physics.particles[i].pos.x;
          //          plane.vertices[i] = vertex;
        }
        plane.computeVertexNormals();
        plane.computeFaceNormals();
        //        plane.computeCentroids();
        plane.__dirtyNormals = true;

      }



			function render() {
        physics.step();
        canvas.width = canvas.width;
               updateVertices();
        checkPointsInsideCar();
        //       drawMargin();
        //  drawPhysics();
        updateCarSize();//TODO ONLY NEEDS TO BE FIRED ON RESIZE?

        if (!animatingToNextPage){
          //calculate new car pos

          var targX = currX-((currX-carX)*.5);
          movementX = currX - targX;
          currX = targX;
          carX = targX;

          if (targX>(rightMarginPerc*canvWid)){
            tarX = carX;
            resetCarPos();
          }

            drawCar(targX, carY, carW, carH, 'rgba(255,0,255,.5)');

        }else{

           drawCar(carX, carY, carW, carH, 'rgba(255,0,255,.5)');

        }

        // mesh.rotation.y += 0.06;
        //  console.log("x:"+mesh.rotation.x);
			 camera.lookAt( scene.position );
			 renderer.render( scene, camera );
			}


      //////////////// UTILITY FUNCTIONS

      function between(min, p, max){
        result = false;

        if ( min < max ){
          if ( p > min && p < max ){
            result = true;
          }
        }

        if ( min > max ){
          if ( p > max && p < min){
            result = true
          }
        }

        if ( p == min || p == max ){
          result = true;
        }

        return result;
      }

      function point_in_rectangle( x, y, left, top, right, bottom){
        result = false;

        if ( between(left,x,right) && between(top,y,bottom ) ){
          result = true;
        }
        return result;
      }



        </script>


   <script>
    (function(window, document){
      var videoElement = function(selector,context){return(context||document).querySelector(selector)};

      var video  = videoElement("video"),
        domPrefixes = 'Webkit Moz O ms Khtml'.split(' ');

      var fullscreen = function(elem) {
        var prefix;
        // Mozilla and webkit intialise fullscreen slightly differently
        for ( var i = -1, len = domPrefixes.length; ++i < len; ) {
              prefix = domPrefixes[i].toLowerCase();

          if ( elem[prefix + 'EnterFullScreen'] ) {
                // Webkit uses EnterFullScreen for video
          return prefix + 'EnterFullScreen';
          break;
              } else if( elem[prefix + 'RequestFullScreen'] ) {
          // Mozilla uses RequestFullScreen for all elements and webkit uses it for non video elements
          return prefix + 'RequestFullScreen';
          break;
          }
            }

        return false;
      };

      // Will return fullscreen method
      var fullscreenvideo = fullscreen(document.createElement("video"));


      if(!fullscreen) {
        alert("Fullscreen won't work, please make sure you're using a browser that supports it and you have enabled the feature");
        return;
      }

      video.addEventListener("webkitfullscreenchange",function(){
        console.log(document.webkitIsFullScreen);
      }, false);

      videoElement("#fs").addEventListener("touchstart", function(){
        // The test returns a string so we can easily call it on a click event
        video[fullscreenvideo]();
        console.log(11);
      }, false);

    })(this, this.document);
  </script>





</body>
</html>