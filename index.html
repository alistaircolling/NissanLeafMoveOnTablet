
<!DOCTYPE html>
<html>

<html>
<head>
    <script type="text/javascript" charset="utf-8" src="js/vendor/zepto.min.js"></script>

    <script src="js/ImprovedNoise.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/jquery-1.6.4.min.js"></script>
    <script src="js/MinimalComps-0.1.min.js"></script>
    <script src="js/TweenLite.min.js"></script>

  <!---  PHYSICS LIBRARIES   --->

<!--     <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="http://cdn.iamwebdeveloper.in/js/stats.js/r11/Stats.js"></script> -->
    <!-- Core -->
    <script src="js/compiled/base.js"></script>
  <script src="js/sketch.min.js"></script>
    <script src="js/compiled/math/Random.js"></script>
    <script src="js/compiled/math/Vector.js"></script>
    <!-- Integratjs/ors -->
    <script src="js/compiled/engine/integrator/Integrator.js"></script>
    <script src="js/compiled/engine/integrator/Euler.js"></script>
    <script src="js/compiled/engine/integrator/ImprovedEuler.js"></script>
    <script src="js/compiled/engine/integrator/Verlet.js"></script>
    <!-- Engine -js/-->
    <script src="js/compiled/engine/Particle.js"></script>
    <script src="js/compiled/engine/Physics.js"></script>
    <script src="js/compiled/engine/Spring.js"></script>
    <!-- Behavioujs/rs -->
    <script src="js/compiled/behaviour/Behaviour.js"></script>
    <script src="js/compiled/behaviour/Attraction.js"></script>
    <script src="js/compiled/behaviour/Collision.js"></script>
    <script src="js/compiled/behaviour/ConstantForce.js"></script>
    <script src="js/compiled/behaviour/EdgeBounce.js"></script>
    <script src="js/compiled/behaviour/EdgeWrap.js"></script>
    <script src="js/compiled/behaviour/Wander.js"></script>


  <!-----  MAY NOT NEED THEM ALL !   ------>

    <link type="text/css" rel="stylesheet" href="styles/normalize.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css" />
    <link type="text/css" rel="stylesheet" href="styles/main.css" />


    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
    <meta http-equiv="cleartype" content="on">
    <meta name="§xapple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="viewport" content = "width = device-width, initial-scale = 1, minimum-scale = 1, maximum-scale = 1, user-scalable = no" />
    <title></title>
</head>


<body>
  <canvas id="surface" width="100%" height="100%" style='z-index : 0; position: absolute;'></canvas>
  <div id="container" style='z-index : 1; position: absolute;'></div>
<!--  <div id="red" style="width: 100px; height: 100px; background-color: red;">page 1</div>
  <div style="width: 100px; height: 100px; background-color: green; display: none;" id="green">page 2</div>
  <div style="width: 100px; height: 100px; background-color: green; display: none;" id="black">>page 3</div>
  <div style="width: 100px; height: 100px; background-color: yellow; display: none;" id="yellow">page 3</div> -->




    <script>


      var container, stats;

			var camera, scene, renderer;

			var mesh;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

      var targetRotation = 0;
      var targetRotationOnMouseDown = 0;

      var mouseX = 0;
      var mouseXOnMouseDown = 0;


      ////CAR VARS


      var carX = 0;
      var currX = 0;
      var carWidthPerc = .2;
      var carHeightPerc = .1;
      var carInitY = .68;
      var carInitX = -.05;
      var offRightPerc = 1.3;
      var rightMarginPerc = .9;


      var canvas ;//= document.getElementById('surface');
      var context;// = canvas.getContext('2d');

      var currentPage = 0;
      var totalPages = 4;
      var animatingToNextPage = false;

      var animTarg = false;
      var carVisible = true;

      var CAR_ANIM_OFF_DURATION = 1;
      var CAR_ANIM_IN_DURATION = 1;

      ////PHYSICS

      var physics, avoidMouse, pullToCenter, collision, example, cell;
      //TODO- use a quality variable that sets the number of squares so the number of rows and columns are calculated for the orientation
      var COLUMNS = 10;
      var ROWS = 10;
      var PARTICLE_RADIUS = 5;


      initTouch();
      initPhysics();
      //   init3D();
     // showdiv(0);

       function initTouch(){

        canvas = document.getElementById('surface');
        context = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
         //   document.addEventListener( 'touchmove', onDocumentTouchMove, false );

       }




      function initPhysics(){

        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        physics = new Physics();
        physics.integrator = new Verlet();
        avoidMouse = new Attraction();
        pullToCenter = new Attraction();
        collision = new Collision();
        setupExample();
      }

      function setupExample(){

        ///SETUP

        example = Sketch.create({container:document.body});
        example.setup = function() {


          var spaceX = Math.floor(window.innerWidth/COLUMNS);
          var spaceY = Math.floor(window.innerHeight/ROWS);
          var s, stiffness, size;
          size = 80;
          stiffness = 0.5;
          cell = [];
          for ( var i = 0; i < COLUMNS+1; i++ ) {
            //create a new array at each index
            cell[i] = [];
            for( var j = 0; j<ROWS+1; j++){

              var particle = new Particle( .1 );
              //fix the top ones
              if (j==0){
                particle.fixed = j === 0;
              }
              var position = new Vector( spaceX*i, spaceY*j );
              particle.moveTo( position );
              particle.setRadius( PARTICLE_RADIUS );

              if (i>0){
                s = new Spring(particle, cell[i-1][j], spaceX, stiffness );
                physics.springs.push(s);
              }


              if (j > 0) {
                s = new Spring(particle, cell[i][j - 1], spaceY, stiffness);
                physics.springs.push(s);
              }



              // Make it collidable
              //  collision.pool.push( particle );

              // Apply behaviours
              //  particle.behaviours.push( avoidMouse, pullToCenter, collision );

              // Add to the simulation
              physics.particles.push( particle );
              cell[i][j] = particle;

            }

          }

          /*    pullToCenter.target.x = this.width / 2;
          pullToCenter.target.y = this.height / 2;
          pullToCenter.strength = 500;
          avoidMouse.setRadius( 200 );
          avoidMouse.strength = -3000;*/

          example.fillStyle = '#ff00ff';
        }
        ////DRAW


        example.draw = function(){

          physics.step();

          //render particles
          for( var i=0, n = physics.particles.length; i<n; i++){

            var particle = physics.particles[i];
            example.beginPath();
            example.arc( particle.pos.x, particle.pos.y, particle.radius, 0, Math.PI * 2 );
            example.fill();
            example.closePath();

          }


          var spring;
          //render springs
          for (i=0; i<physics.springs.length; i++){
            example.strokeStyle = '#ffff00';
            spring = physics.springs[i];
            example.beginPath();
            example.moveTo(spring.p1.pos.x, spring.p1.pos.y);
            example.lineTo(spring.p2.pos.x, spring.p2.pos.y);
            example.closePath();
            example.stroke();

          }



        }

        /*    example.mousemove = function() {
          console.log("mov");
          avoidMouse.target.x = example.mouse.x;
          avoidMouse.target.y = example.mouse.y;

        }*/

      }

			function init3D() {


				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1320;

				scene = new THREE.Scene();

				var data = generateHeight( 1024, 1024 );
				var texture = new THREE.Texture( generateTexture( data, 1024, 1024 ) );
				texture.needsUpdate = true;

        //				var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: true } );
        var material = new THREE.MeshNormalMaterial();
        material.doubleSided = true;

				var quality = 8, step = 1024 / quality;

				var plane = new THREE.PlaneGeometry( 768, 1024, quality - 1, quality - 1 );
				plane.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
        console.log(plane);
				for ( var i = 0, l = plane.vertices.length; i < l; i ++ ) {

					var x = i % quality, y = ~~ ( i / quality );
					plane.vertices[ i ].y = data[ ( x * step ) + ( y * step ) * 1024 ] * 2 - 128;

				}

				plane.computeCentroids();

				mesh = new THREE.Mesh( plane, material );
				scene.add( mesh );

				renderer = new THREE.CanvasRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );

        //	container.innerHTML = "";

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );


				window.addEventListener( 'resize', onWindowResize, false );
        mesh.rotation.x = Math.PI*.5;

        //mouse touch listeners
        //˚document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );
        document.addEventListener( 'touchend', onDocumentTouchUp, false );

        //    addControls();
        animate();
			}

      var cameraZSlider;

      function addControls(){
        container = document.getElementById( 'container' );

        cameraZSlider = new mc.HSlider(container, 10, 80, onCamZSliderChange)
        .bindLabel(new mc.Label(container, 15, 100).setAlign("center"), 0);
        cameraZSlider.setMinimum( -6000 );
    		cameraZSlider.setMaximum( 6000 );


      }

      function onCamZSliderChange( e ){

        camera.position.z = cameraZSlider.getValue();
        console.log("Camera z change:"+camera.position.z);
    	}




      ///////   MOUSE LISTENERS   //////////////

      function onDocumentMouseDown(){
        console.log("m down");
        event.preventDefault();
        mouseXOnMouseDown = event.clientX - windowHalfX;
        targetRotationOnMouseDown = targetRotation;

      }


      function onDocumentMouseMove( e ) {
          console.log("mmove");
          mouseX = event.clientX - windowHalfX;
          targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
          console.log(targetRotation);
      }

      function onDocumentMouseUp( event ) {

          document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
          document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
          document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

      }


     function onDocumentMouseOut( event ) {

          document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
          document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
          document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

      }

    var tDown = false;

      //////////  TOUCH LISTENERS //////////////////


      function onDocumentTouchStart(event){
        var x = event.targetTouches[0].pageX;
        var y = event.targetTouches[0].pageY;
        console.log("t start:"+x+":"+y);
        avoidMouse.target.x = x;
        avoidMouse.target.y = y;
        tDown = true;
        event.preventDefault();
      }

      function onDocumentTouchUp(event){
        console.log("t up");
        tDown = false;
        event.preventDefault();
      }


      var currX = 0;

      function onDocumentTouchMove(event){

        var x = event.targetTouches[0].pageX,
        y = event.targetTouches[0].pageY;

         console.log("mov:"+x,y);
        if (!animTarg){
          currX = x;
        }


        //        drawCircle(x,y, 40, '#ffff00');
        /*
        camera.position.z = ((y/window.innerHeight)*6000);
        mesh.rotation.z =((x/window.innerWidth)*Math.PI*2);
        console.log(mesh.rotation.y);
*/
         avoidMouse.target.x = x;
          avoidMouse.target.y = y;
        event.preventDefault();



      }

      //////////////////////////////////////

      function drawCircle(x, y, radius, color){
        canvas.width  =canvas.width;
        context.beginPath();
        context.fillStyle = color;
        context.arc(x,y,radius,0,Math.PI*2);
        context.fill();
      }


			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function generateHeight( width, height ) {

				var data = Float32Array ? new Float32Array( width * height ) : [], perlin = new ImprovedNoise(),
				size = width * height, quality = 2, z = Math.random() * 100;

				for ( var i = 0; i < size; i ++ ) {

					data[ i ] = 0

				}

				for ( var j = 0; j < 4; j ++ ) {

					quality *= 4;

					for ( var i = 0; i < size; i ++ ) {

						var x = i % width, y = ~~ ( i / width );
						data[ i ] += Math.floor( Math.abs( perlin.noise( x / quality, y / quality, z ) * 0.5 ) * quality + 10 );


					}

				}

				return data;

			}

			function generateTexture( data, width, height ) {

				var canvas, context, image, imageData,
				level, diff, vector3, sun, shade;

				vector3 = new THREE.Vector3( 0, 0, 0 );

				sun = new THREE.Vector3( 1, 1, 1 );
				sun.normalize();

				canvas = document.createElement( 'canvas' );
				canvas.width = width;
				canvas.height = height;

				context = canvas.getContext( '2d' );
				context.fillStyle = '#000';
				context.fillRect( 0, 0, width, height );

				image = context.getImageData( 0, 0, width, height );
				imageData = image.data;

				for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++  ) {

					vector3.x = data[ j - 1 ] - data[ j + 1 ];
					vector3.y = 2;
					vector3.z = data[ j - width ] - data[ j + width ];
					vector3.normalize();

					shade = vector3.dot( sun );

					imageData[ i ] = ( 96 + shade * 128 ) * ( data[ j ] * 0.007 );
					imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( data[ j ] * 0.007 );
					imageData[ i + 2 ] = ( shade * 96 ) * ( data[ j ] * 0.007 );

				}

				context.putImageData( image, 0, 0 );

				return canvas;

			}

			function onDocumentMouseMove(event) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

      //THIS FUNCTION WILL BE CALLED WHEN THE CAR HAS REACHED THE RIGHT MARGIN

      function showNextPage(){
        //increment or reset the page number
        if (currentPage<totalPages-1){
          currentPage++;
          console.log("display  " + currentPage);
        }else{
          currentPage = 0;
        }


        showDivs(currentPage);//add code to show correct content here:

      }



      function updateVertices(){


      }

     function showDivs(id) {
       var ids = ["red", "green", "black", "yellow"];
        console.log(ids);
        for(var i = 0; i < ids.length; i++) {


          if(i == currentPage){
            var lastPage = currentPage-1;
            if (lastPage<0){
              lastPage = totalPages-1;
            }
            var currDiv = document.getElementById(ids[lastPage]);
            currDiv.style.display = "none";
            var thisD = document.getElementById(ids[currentPage]);
            console.log("div?:"+thisD);
            thisD.style.display = "block";

          }

        }

      }


      function drawMargin(){

        context.beginPath();
        context.fillStyle = '#505050';
        context.fillRect(window.innerWidth*rightMarginPerc, 0, window.innerWidth*(1-rightMarginPerc), window.innerHeight);
        context.fill();



      }


      function drawCircle(x, y, radius, color){
        canvas.width  =canvas.width;
        context.beginPath();
        context.fillStyle = color;
        context.arc(x,y,radius,0,Math.PI*2);
        context.fill();
      }


      function drawCar(x, y, width, height, color){
        //  console.log("draw"+x+":"+ y);


        context.fillStyle = color;
        context.beginPath();
        context.fillRect(x,y,width,height);
        context.fill();
      }

      function resetCarPos(){
        console.log("reset");
        animatingToNextPage = true;
        animateCarOffRight();


        showNextPage(); // TODO move to when car is off the pagew


      }

      function animateCarOffRight(){
        var targOff = window.innerWidth*offRightPerc;
        console.log("anim offright:"+targOff);

        TweenLite.to(this, CAR_ANIM_OFF_DURATION, {carX:targOff, onComplete:carAtRight});



      }

      function carAtRight(){
        console.log("carAtRight");
        carX = 0-(window.innerWidth*carWidthPerc);
        animateCarIn();

      }

      function animateCarIn(){
        TweenLite.to(this, CAR_ANIM_IN_DURATION, {carX:window.innerWidth*carInitX, onComplete:carIsHere});

      }

      function carIsHere(){
        console.log("car is here");
        currX = carX;

        animatingToNextPage = false;

      }

			function render() {
         canvas.width = canvas.width;
        drawMargin();
        var canvHeigh = window.innerHeight;
        var carY = canvHeigh*carInitY;
        var canvWid = window.innerWidth;
        var carW = canvWid*carWidthPerc;
        var carH = canvHeigh*carHeightPerc;

        if (!animatingToNextPage){
          //calculate new car pos

          var targX = currX-((currX-carX)*.5);
          currX = targX;
          carX = targX;

          if (targX>(rightMarginPerc*canvWid)){
            tarX = carX;
            resetCarPos();
          }

            drawCar(targX, carY, carW, carH, '#ff00ff');

        }else{

           drawCar(carX, carY, carW, carH, '#ff00ff');

        }

        updateVertices();
        //   if (!tDown) mesh.rotation.x += 0.01; mesh.rotation.y += 0.01;
        //
        //		camera.position.x += ( mouseX - camera.position.x ) * 0.05;
        //		camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
				camera.lookAt( scene.position );

				renderer.render( scene, camera );
        //  console.log(carX);

			}



        </script>





</body>
</html>